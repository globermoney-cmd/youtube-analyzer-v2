<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>유튜브 채널 등급 분석기 (V2)</title>
  <style>
    /* CSS 스타일은 이전과 동일하게 유지하여 가독성을 높였습니다. */
    body {
      font-family: "Malgun Gothic", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f7fb;
      color: #222;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px 16px 80px;
    }
    h1 { margin-bottom: 8px; }
    h2 { margin-top: 32px; margin-bottom: 8px; }
    h3 { margin-top: 16px; margin-bottom: 8px; }
    .card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06);
      padding: 16px 20px;
      margin-top: 16px;
    }
    .flex-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .input-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    input[type="text"] {
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #ccc;
      min-width: 260px;
      flex: 1;
    }
    button {
      padding: 8px 14px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-weight: 600;
    }
    .btn-primary   { background: #e53935; color: #fff; }
    .btn-secondary { background: #eee;   color: #333; }
    .small { font-size: 12px; color: #777; }
    .pill  { padding: 3px 6px; border-radius: 999px; font-size: 11px; background: #eee; display: inline-block; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 8px;
    }
    .stat-box {
      background: #fafafa;
      border-radius: 10px;
      padding: 10px 12px;
    }
    .stat-label { font-size: 13px; color: #666; }
    .stat-value { margin-top: 4px; font-size: 18px; font-weight: 700; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }
    th, td {
      border-bottom: 1px solid #eee;
      padding: 6px 8px;
      text-align: left;
      font-size: 13px;
    }
    th { background: #fafafa; font-weight: 600; }
    tr:hover { background: #f9fafc; }
    .page {
      margin-top: 16px;
    }
    .layout-two {
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(280px, 2fr);
      gap: 16px;
      margin-top: 12px;
    }
    iframe {
      width: 100%;
      min-height: 260px;
      border-radius: 8px;
      border: none;
      background: #000;
    }
    textarea {
      width: 100%;
      min-height: 160px;
      border-radius: 8px;
      border: 1px solid #ddd;
      padding: 8px;
      resize: vertical;
      font-family: inherit;
      font-size: 13px;
    }
    .error  { color: #d32f2f; font-size: 13px; margin-top: 4px; }
    .loader { font-size: 13px; color: #555; margin-top: 6px; }

    @media (max-width: 900px) {
      .layout-two { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>유튜브 채널 등급 분석기 (V2)</h1>
  <p class="small">
    채널 ID 또는 커스텀 URL을 입력하고, 채널의 성과와 등급을 분석합니다.<br />
    ※ 등급/수익은 이 도구의 <b>자체 추정</b>이며 유튜브 공식 데이터가 아닙니다.
  </p>

  <div class="card">
    <h2>채널 ID를 입력하고 채널의 성과와 등급을 확인하세요</h2>
    <div class="input-group">
      <label for="channelInput">채널 ID 또는 커스텀 URL 입력 :</label>
      <input id="channelInput" type="text"
             placeholder="예: UCxxxxxx 또는 https://www.youtube.com/@handle" />
      <button class="btn-primary" id="analyzeBtn">분석하기</button>
      <button class="btn-secondary" id="resetBtn">초기화</button>
    </div>
    <div id="inputError" class="error"></div>
    <div id="globalLoader" class="loader" style="display:none;">유튜브 API에서 데이터를 가져오는 중입니다...</div>
  </div>

  <div id="resultArea" style="display:none;">

    <div id="dashboardSection" class="page">
      <div class="card">
        <div class="flex-between">
          <div>
            <div id="channelTitle" style="font-size:20px; font-weight:700;"></div>
            <div style="margin-top:6px;">
              <span class="pill" id="channelGradePill">채널 등급: -</span>
              <span class="small" id="gradeExplain" style="margin-left:8px;"></span>
            </div>
          </div>
          <div style="text-align:right; min-width:220px;">
            <div class="small">구독자: <b id="subscriberCount">-</b>명</div>
            <div class="small">총 영상(갯수): <b id="videoCount">-</b>개</div>
            <div class="small">개설일: <b id="publishedAt">-</b></div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>핵심 성과 지표</h2>
        <div class="grid">
          <div class="stat-box">
            <div class="stat-label">총 조회수</div>
            <div class="stat-value" id="totalViews">-</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">조회수 기준 예상 수익 (전체, 추측입니다)</div>
            <div class="stat-value" id="estimatedRevenue">-</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">최근 30일 신규 영상 조회수(추정)</div>
            <div class="stat-value" id="recentViews30">-</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">최근 30일 신규 영상 예상 수익(추정)</div>
            <div class="stat-value" id="recentRevenue30">-</div>
          </div>
        </div>
        <div class="grid" style="margin-top:12px;">
           <div class="stat-box">
            <div class="stat-label">롱폼(>60초) 예상 수익</div>
            <div class="stat-value" id="longRevenue">-</div>
            <div class="small">롱폼 조회수: <span id="longViews">-</span></div>
          </div>
          <div class="stat-box">
            <div class="stat-label">숏츠(≤60초) 예상 수익</div>
            <div class="stat-value" id="shortRevenue">-</div>
            <div class="small">숏츠 조회수: <span id="shortViews">-</span></div>
          </div>
          <div class="stat-box">
            <div class="stat-label">평균 영상 길이</div>
            <div class="stat-value" id="avgDuration">-</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">업로드 빈도 (최근 30일)</div>
            <div class="stat-value" id="uploadFreq">-</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="flex-between">
          <h2>영상 목록 (최근 100개)</h2>
          <button class="btn-primary" id="startAnalysisBtn">선택한 영상 학습/분석 시작</button>
        </div>
        <p class="small">
          영상 제목을 클릭하여 목록에서 선택할 수 있습니다. 선택 후 '선택한 영상 학습/분석 시작' 버튼을 누르세요.
        </p>
        <div id="videoListLoader" class="loader" style="display:none;">영상 목록을 불러오는 중입니다...</div>
        <table id="videosTable">
          <thead>
          <tr>
            <th style="width:30px;"><input type="radio" name="videoSelect" disabled></th>
            <th>영상 제목</th>
            <th style="width:90px;">업로드일</th>
            <th style="width:90px;">길이</th>
            <th style="width:100px;">조회수</th>
          </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div class="card page" id="learningArea" style="display:none;">
      <div class="flex-between">
        <h2>영상 학습 및 분석: <span id="learningVideoTitle"></span></h2>
        <button class="btn-secondary" id="backToDashboardBtn">대시보드로 돌아가기</button>
      </div>
      <p class="small" style="margin-bottom:4px;">
        선택한 영상의 조회수/좋아요/댓글을 확인하고, 대본을 가져온 뒤 간단한 AI 분석을 수행합니다.
      </p>

      <div class="layout-two">
        <div>
          <div class="small" style="margin-bottom:6px;">
            <span>조회수: <b id="vh-views">0회</b></span> |
            <span>좋아요: <b id="vh-likes">0개</b></span> |
            <span>댓글: <b id="vh-comments">0개</b></span> |
            <span id="vh-date">-</span>
          </div>
          <iframe id="learningVideoPlayer"
                  src=""
                  referrerpolicy="strict-origin-when-cross-origin"
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                  allowfullscreen></iframe>
        </div>
        <div>
          <h3>영상 대본 &amp; AI 분석</h3>
          <div style="margin-top:6px; margin-bottom:4px;">
            <button class="btn-primary" id="fetchTranscriptBtn">대본 가져오기 &amp; 분석</button>
          </div>
          <div class="small" style="margin-bottom:4px;"><b>영상 대본</b></div>
          <textarea id="transcriptArea" placeholder="대본 가져오기 버튼을 누르면 영상 대본이 여기에 표시됩니다. (자막이 없는 영상은 실패합니다)" readonly></textarea>
          <div class="small" style="margin-top:8px; margin-bottom:4px;"><b>AI(간단) 분석 결과</b> <span class="small">(규칙 기반 자동 분석 · 추측입니다)</span></div>
          <textarea id="analysisArea" placeholder="대본을 바탕으로 한 간단 분석 결과가 여기에 표시됩니다."></textarea>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // =======================================================
  // ★★★ 1. 사용자 설정 영역: 여기에 API 키를 붙여넣으세요 ★★★
  // =======================================================
  const API_KEY = "AIzaSyAZSs_ZMHZRAg7dd3EHD_1QB5lyQGSIQyg";
  const YT_API_BASE = "https://www.googleapis.com/youtube/v3";

  // 자체 추정 수익 계산용 (롱폼: CPM 1500원, 숏츠: CPM 400원)
  const LONGFORM_CPM = 1500;
  const SHORTS_CPM   = 400;
  // =======================================================

  let currentChannelId = null;
  let currentUploadsPlaylistId = null;
  let allVideos = [];
  let selectedVideo = null;

  const nf = new Intl.NumberFormat("ko-KR");

  function $(id) { return document.getElementById(id); }

  // 헬퍼 함수: DOM/UI 관련
  function showResultArea(show) { $("resultArea").style.display = show ? "block" : "none"; }
  function showLearningArea(show) {
    if (show) {
      $("learningArea").style.display = "block";
      $("dashboardSection").style.display = "none";
      window.scrollTo(0,0);
    } else {
      $("learningArea").style.display = "none";
      $("dashboardSection").style.display = "block";
      window.scrollTo(0,0);
    }
  }
  function setGlobalLoader(show, msg) {
    $("globalLoader").style.display = show ? "block" : "none";
    if (msg) $("globalLoader").textContent = msg;
  }
  function setInputError(msg) { $("inputError").textContent = msg || ""; }
  function isoToDateStr(iso) {
    if (!iso) return "-";
    const d = new Date(iso);
    if (Number.isNaN(d.getTime())) return "-";
    return d.getFullYear() + "-" + String(d.getMonth()+1).padStart(2,"0") + "-" + String(d.getDate()).padStart(2,"0");
  }
  function formatDuration(sec) {
    if (sec == null || !Number.isFinite(sec)) return "-";
    if (sec === 0) return "0:00";
    const h = Math.floor(sec / 3600);
    const m = Math.floor((sec % 3600)/60);
    const s = sec % 60;
    if (h>0) return h + ":" + String(m).padStart(2,"0") + ":" + String(s).padStart(2,"0");
    return m + ":" + String(s).padStart(2,"0");
  }
  function parseISODuration(iso) {
    if (!iso || iso.indexOf("PT") !== 0) return 0;
    const m = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!m) return 0;
    return parseInt(m[1]||"0",10)*3600 + parseInt(m[2]||"0",10)*60 + parseInt(m[3]||"0",10);
  }
  function classifyGrade(subs, avgViewsPerVideo) {
    let grade = "C";
    let explain = "자체 기준: 성장 가능성이 있는 채널입니다.";
    if (subs >= 100000 && avgViewsPerVideo >= 50000) {
      grade = "S"; explain = "뛰어난 영향력과 조회수를 가진 최상위 채널입니다. (비공식 자체 기준)";
    } else if (subs >= 50000 && avgViewsPerVideo >= 20000) {
      grade = "A"; explain = "안정적인 구독자 기반과 우수한 조회수를 가진 상위 채널입니다. (비공식 자체 기준)";
    } else if (subs >= 10000) {
      grade = "B"; explain = "탄탄한 성장세를 가진 중상위 채널입니다. (비공식 자체 기준)";
    }
    return { grade, explain };
  }
  function calculateRevenue(views, cpm) {
    if (!views || !cpm) return 0;
    return Math.round((views * cpm) / 1000);
  }

  // 헬퍼 함수: YouTube Data API 호출
  async function fetchJson(url) {
    const res = await fetch(url);
    if (!res.ok) {
      let txt = await res.text();
      try {
        const json = JSON.parse(txt);
        throw new Error(json.error && json.error.message ? `API 오류: ${json.error.code} - ${json.error.message}` : `API 오류: ${res.status}`);
      } catch (e) {
        throw new Error(`API 오류: ${res.status} - JSON 파싱 실패`);
      }
    }
    return res.json();
  }
  function buildChannelsUrlByInput(raw) {
    const url = new URL(YT_API_BASE + "/channels");
    url.searchParams.set("key", API_KEY);
    url.searchParams.set("part", "snippet,statistics,contentDetails");
    let input = raw.trim();
    // 복잡한 URL 처리 로직 (이전 코드와 동일하게 유지)
    if (input.indexOf("youtube.com") !== -1) {
      try {
        const u = new URL(input);
        const path = u.pathname;
        if (path.indexOf("/channel/") !== -1) {
          url.searchParams.set("id", path.split("/channel/")[1].split("/")[0]);
          return url.toString();
        }
        if (path.indexOf("/@") === 0) {
          url.searchParams.set("forHandle", path.substring(2));
          return url.toString();
        }
      } catch(e){}
    }
    if (input.indexOf("UC") === 0) {
      url.searchParams.set("id", input);
    } else if (input.indexOf("@") === 0) {
      url.searchParams.set("forHandle", input.substring(1));
    } else {
      url.searchParams.set("forHandle", input);
    }
    return url.toString();
  }
  async function fetchChannel(rawInput) {
    const url = buildChannelsUrlByInput(rawInput);
    const data = await fetchJson(url);
    if (!data.items || !data.items.length) throw new Error("채널을 찾을 수 없습니다. 입력을 확인해 주세요.");
    return data.items[0];
  }
  async function fetchUploadsPlaylistItems(playlistId, maxResults=100) {
    let items = [];
    let pageToken = "";
    while (items.length < maxResults) {
      const url = new URL(YT_API_BASE + "/playlistItems");
      url.searchParams.set("key", API_KEY);
      url.searchParams.set("part", "contentDetails,snippet");
      url.searchParams.set("playlistId", playlistId);
      url.searchParams.set("maxResults", "50");
      if (pageToken) url.searchParams.set("pageToken", pageToken);
      const data = await fetchJson(url.toString());
      items = items.concat(data.items || []);
      pageToken = data.nextPageToken || "";
      if (!pageToken) break;
    }
    return items.slice(0, maxResults);
  }
  async function fetchVideosDetails(videoIds) {
    if (!videoIds.length) return [];
    const chunks = [];
    for (let i=0; i<videoIds.length; i+=50) chunks.push(videoIds.slice(i, i+50));
    let all = [];
    for (let i=0; i<chunks.length; i++) {
      const c = chunks[i];
      const url = new URL(YT_API_BASE + "/videos");
      url.searchParams.set("key", API_KEY);
      url.searchParams.set("part", "contentDetails,statistics,snippet");
      url.searchParams.set("id", c.join(","));
      const data = await fetchJson(url.toString());
      all = all.concat(data.items || []);
    }
    return all;
  }
  // 헬퍼 함수: 대본 (자막) 가져오기
  async function fetchTranscript(videoId) {
    // YouTube의 비공식 자막 API 엔드포인트를 사용합니다. (브라우저의 CORS 정책에 따라 실패 가능성 있음)
    const langs = ["ko","ko-kr","en"];
    for (let i=0;i<langs.length;i++) {
      const lang = langs[i];
      const url = "https://video.google.com/timedtext?lang=" + encodeURIComponent(lang) +
                  "&v=" + encodeURIComponent(videoId);
      try {
        const res = await fetch(url);
        if (!res.ok) continue;
        const xml = await res.text();
        if (!xml.trim()) continue;
        // XML에서 텍스트만 추출
        const matches = xml.matchAll(/<text[^>]*>([^<]*)<\/text>/g);
        const arr = [];
        for (const m of matches) {
          let t = m[1];
          t = t.replace(/&amp;/g,"&")
               .replace(/&quot;/g,'"')
               .replace(/&#39;/g,"'")
               .replace(/&lt;/g,"<")
               .replace(/&gt;/g,">");
          arr.push(t);
        }
        if (!arr.length) continue;
        return arr.join("\n");
      } catch(e){
        continue;
      }
    }
    throw new Error("사용 가능한 자막을 찾을 수 없습니다.");
  }

  // 헬퍼 함수: 간단 AI 분석 (규칙 기반)
  function buildAnalysis(text, video) {
    const chars = text.length;
    const words = text.split(/\s+/).filter(Boolean).length;
    
    // 키워드 빈도 분석 (2글자 이상 단어만)
    const tokens = text
      .replace(/[^\p{Letter}\p{Number}\s]/gu," ")
      .split(/\s+/)
      .map(t=>t.trim())
      .filter(t=>t.length>=2);
    const freq = {};
    tokens.forEach(t=>{
      const key = t.toLowerCase();
      freq[key] = (freq[key]||0)+1;
    });
    const entries = Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,5);
    const top = entries.map(([k,v])=>`- ${k} (${v}회)`);

    const preview = text.slice(0,200);

    return `[AI(간단) 분석 · 규칙 기반 · 추측입니다]

- 영상 제목: ${video.title}
- 영상 길이: ${formatDuration(video.durationSec || 0)}
- 조회수: ${nf.format(video.viewCount || 0)}회

[텍스트 통계]
- 문자 수: ${nf.format(chars)}
- 단어 수(공백 기준): ${nf.format(words)}

[자주 등장하는 키워드 상위 5개]
${top.length ? top.join("\n") : "- 분석할 키워드가 충분하지 않습니다."}

[내용 미리보기]
${preview}${text.length>200 ? "..." : ""}`;
  }


  // UI 업데이트 로직: 대시보드
  function updateDashboard(channel, videos) {
    const snippet = channel.snippet;
    const stats   = channel.statistics;

    $("channelTitle").textContent = snippet.title || "(제목 없음)";
    const subs = parseInt(stats.subscriberCount || "0",10);
    const totalViewCount = parseInt(stats.viewCount || "0",10);
    const videoCount = parseInt(stats.videoCount || "0",10);

    $("subscriberCount").textContent = nf.format(subs);
    $("videoCount").textContent = nf.format(videoCount);
    $("publishedAt").textContent = isoToDateStr(snippet.publishedAt);
    $("totalViews").textContent = nf.format(totalViewCount);

    const avgViewsPerVideo = videoCount>0 ? Math.round(totalViewCount / videoCount) : 0;
    const { grade, explain } = classifyGrade(subs, avgViewsPerVideo);
    $("channelGradePill").textContent = "채널 등급: " + grade;
    $("gradeExplain").textContent = explain;

    if (!videos || !videos.length) return;

    let totalDuration=0;
    let recentViewsSum=0, recentCount=0;
    let lastUpload=null;
    let longViews=0, shortViews=0;
    let recentLongViews=0, recentShortViews=0;

    const now = new Date();
    const THIRTY = 30*24*60*60*1000;

    videos.forEach(v=>{
      const dur = v.durationSec || 0;
      totalDuration += dur;
      const views = v.viewCount || 0;

      const isLong = dur > 60;
      if (isLong) longViews += views;
      else        shortViews += views;

      const pub = new Date(v.publishedAt);
      if (!Number.isNaN(pub.getTime())){
        if (!lastUpload || pub>lastUpload) lastUpload = pub;
        if (now - pub <= THIRTY){
          recentViewsSum += views;
          recentCount++;
          if (isLong) recentLongViews += views;
          else        recentShortViews += views;
        }
      }
    });

    const avgDur = Math.round(totalDuration / videos.length);
    $("avgDuration").textContent = formatDuration(avgDur);

    const longRev  = calculateRevenue(longViews, LONGFORM_CPM);
    const shortRev = calculateRevenue(shortViews, SHORTS_CPM);
    const estTotalRevenue = longRev + shortRev;

    $("estimatedRevenue").textContent = estTotalRevenue ? nf.format(estTotalRevenue) + "원" : "-";
    $("longViews").textContent  = nf.format(longViews)  + "회";
    $("shortViews").textContent = nf.format(shortViews) + "회";
    $("longRevenue").textContent  = longRev  ? nf.format(longRev)  + "원" : "-";
    $("shortRevenue").textContent = shortRev ? nf.format(shortRev) + "원" : "-";

    $("recentViews30").textContent = recentViewsSum ? nf.format(recentViewsSum) + "회" : "-";
    const recentLongRev  = calculateRevenue(recentLongViews, LONGFORM_CPM);
    const recentShortRev = calculateRevenue(recentShortViews, SHORTS_CPM);
    const recentTotalRev = recentLongRev + recentShortRev;
    $("recentRevenue30").textContent = recentTotalRev ? nf.format(recentTotalRev) + "원" : "-";

    $("uploadFreq").textContent = recentCount ? `${recentCount}개/30일` : "-";
  }

  // UI 업데이트 로직: 영상 목록 테이블
  function updateVideosTable(videos){
    const tbody = $("videosTable").querySelector("tbody");
    tbody.innerHTML = "";
    videos.forEach((v, idx)=>{
      const tr = document.createElement("tr");
      tr.dataset.videoId = v.id;
      tr.innerHTML =
        `<td><input type="radio" name="videoSelect" data-video-id="${v.id}"></td>
         <td><span class="video-title" style="cursor:pointer;">${v.title}</span></td>
         <td>${isoToDateStr(v.publishedAt)}</td>
         <td>${formatDuration(v.durationSec)}</td>
         <td>${nf.format(v.viewCount||0)}</td>`;

      // 제목 클릭 시 라디오 버튼 선택
      tr.querySelector(".video-title").addEventListener("click", ()=>{
        tr.querySelector('input[type="radio"]').checked = true;
      });

      tbody.appendChild(tr);
    });
  }

  // UI 업데이트 로직: 학습 페이지
  function startLearning(video) {
    selectedVideo = video;
    showLearningArea(true);

    $("learningVideoTitle").textContent = video.title;
    $("vh-views").textContent    = nf.format(video.viewCount||0)    + "회";
    $("vh-likes").textContent    = nf.format(video.likeCount||0)    + "개";
    $("vh-comments").textContent = nf.format(video.commentCount||0) + "개";
    $("vh-date").textContent     = isoToDateStr(video.publishedAt);

    // YouTube 임베드 플레이어 로드
    const iframe = $("learningVideoPlayer");
    iframe.src =
      "https://www.youtube-nocookie.com/embed/" +
      encodeURIComponent(video.id) +
      "?rel=0&modestbranding=1";

    $("transcriptArea").value = "대본을 가져오세요.";
    $("analysisArea").value   = "분석 대기 중...";
  }


  // =======================================================
  // 이벤트 바인딩 및 메인 로직
  // =======================================================
  document.addEventListener("DOMContentLoaded", () => {

    // 1. 분석하기 버튼
    $("analyzeBtn").addEventListener("click", async ()=>{
      const input = $("channelInput").value.trim();
      setInputError("");
      if (!input) { setInputError("채널 ID 또는 URL을 입력해 주세요."); return; }
      if (API_KEY === "여기에_사용자님의_YouTube_API_키를_붙여넣으세요") { setInputError("코드 상단의 API_KEY를 먼저 설정해 주세요."); return; }

      setGlobalLoader(true, "채널 정보를 불러오는 중입니다...");
      showResultArea(false);
      allVideos = [];
      $("analyzeBtn").disabled = true;

      try {
        const channel = await fetchChannel(input);
        currentChannelId = channel.id;
        currentUploadsPlaylistId = channel.contentDetails &&
                                   channel.contentDetails.relatedPlaylists &&
                                   channel.contentDetails.relatedPlaylists.uploads;

        if (!currentUploadsPlaylistId) {
             throw new Error("채널의 업로드 재생목록 ID를 찾을 수 없습니다. 영상이 비공개이거나 채널이 비활성 상태일 수 있습니다.");
        }

        // 1-1. 영상 목록 가져오기 (최근 100개)
        setGlobalLoader(true,"채널 영상 목록을 가져오는 중입니다...(최대 100개)");
        const playlistItems = await fetchUploadsPlaylistItems(currentUploadsPlaylistId, 100);
        const ids = playlistItems.map(it=>it.contentDetails && it.contentDetails.videoId).filter(Boolean);
        let videoDetails = [];
        if (ids.length) videoDetails = await fetchVideosDetails(ids);

        allVideos = videoDetails.map(v=>{
          const cd = v.contentDetails || {};
          const st = v.statistics || {};
          const sn = v.snippet   || {};
          const durationSec = parseISODuration(cd.duration);
          return {
            id: v.id,
            title: sn.title || "(제목 없음)",
            publishedAt: sn.publishedAt || "",
            viewCount: parseInt(st.viewCount || "0",10),
            likeCount: parseInt(st.likeCount || "0",10),
            commentCount: parseInt(st.commentCount || "0",10),
            durationSec
          };
        });

        updateDashboard(channel, allVideos);
        updateVideosTable(allVideos);

        setGlobalLoader(false);
        showResultArea(true);
        showLearningArea(false);
      } catch(e){
        setGlobalLoader(false);
        setInputError(e.message || "알 수 없는 오류가 발생했습니다.");
      } finally {
        $("analyzeBtn").disabled = false;
      }
    });

    // 2. 초기화 버튼
    $("resetBtn").addEventListener("click", ()=>{
      $("channelInput").value = "";
      setInputError("");
      showResultArea(false);
      allVideos = [];
      currentChannelId = null;
      selectedVideo = null;
    });

    // 3. 분석 시작 버튼
    $("startAnalysisBtn").addEventListener("click", ()=>{
      const checkedRadio = document.querySelector('input[name="videoSelect"]:checked');
      if (!checkedRadio) {
        alert("분석할 영상을 먼저 목록에서 선택(클릭)해 주세요.");
        return;
      }
      const videoId = checkedRadio.dataset.videoId;
      const videoToAnalyze = allVideos.find(v=>v.id===videoId);
      if (videoToAnalyze) {
        startLearning(videoToAnalyze);
      }
    });

    // 4. 대시보드 돌아가기 버튼
    $("backToDashboardBtn").addEventListener("click", ()=>showLearningArea(false));

    // 5. 대본 가져오기 & 분석 버튼
    $("fetchTranscriptBtn").addEventListener("click", async ()=>{
      if (!selectedVideo) return;

      $("transcriptArea").value = "대본을 가져오는 중입니다...\n(일부 영상은 자막이 없거나 실패할 수 있습니다)";
      $("analysisArea").value   = "분석 중...";
      $("fetchTranscriptBtn").disabled = true;

      try {
        const text = await fetchTranscript(selectedVideo.id);
        $("transcriptArea").value = text;
        const analysis = buildAnalysis(text, selectedVideo);
        $("analysisArea").value   = analysis;
      } catch (e) {
        $("transcriptArea").value = "대본을 가져오지 못했습니다.\n사유: " + (e.message || "알 수 없는 오류");
        $("analysisArea").value   = "대본이 없어 분석할 수 없습니다.";
      } finally {
        $("fetchTranscriptBtn").disabled = false;
      }
    });

  });
</script>
</body>
</html>